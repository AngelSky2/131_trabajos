Laboratorio 09012025
====================
---1---
public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello, World!");
    }
}
---2---
import java.util.Vector;

public class VectorExample {
    public static void main(String[] args) {
        // Crear un vector de enteros
        Vector<Integer> numbers = new Vector<>();

        // Agregar elementos al vector
        numbers.add(10);
        numbers.add(20);
        numbers.add(30);

        // Imprimir el vector
        System.out.println("Vector: " + numbers);

    }
}

---3---
import java.util.Vector;

public class AccessVectorElements {
    public static void main(String[] args) {
        // Crear un vector de cadenas
        Vector<String> names = new Vector<>();
        names.add("Alice");
        names.add("Bob");
        names.add("Charlie");

        // Acceder a elementos por √≠ndice
        System.out.println("Primer elemento: " + names.get(0));
        System.out.println("Segundo elemento: " + names.get(1));

        // Recorrer el vector usando un bucle
        System.out.println("Todos los elementos:");
        for (String name : names) {
            System.out.println(name);
        }
    }
}
---4---
import java.util.Vector;

public class ModifyVector {
    public static void main(String[] args) {
        // Crear un vector de n√∫meros
        Vector<Integer> numbers = new Vector<>();
        numbers.add(10);
        numbers.add(20);
        numbers.add(30);

        // Insertar un elemento en una posici√≥n espec√≠fica
        numbers.add(1, 15); // Insertar 15 en el √≠ndice 1
        System.out.println("Despu√©s de insertar: " + numbers);

        // Eliminar un elemento por √≠ndice
        numbers.remove(2); // Eliminar el elemento en el √≠ndice 2
        System.out.println("Despu√©s de eliminar: " + numbers);

        // Eliminar un elemento por valor
        numbers.remove((Integer) 15); // Eliminar el n√∫mero 15
        System.out.println("Despu√©s de eliminar por valor: " + numbers);
    }
}
---5---
import java.util.Vector;

public class SearchVector {
    public static void main(String[] args) {
        // Crear un vector de n√∫meros
        Vector<Integer> numbers = new Vector<>();
        numbers.add(5);
        numbers.add(10);
        numbers.add(15);
        numbers.add(20);

        // Verificar si un elemento est√° en el vector
        int searchNumber = 10;
        if (numbers.contains(searchNumber)) {
            System.out.println("El n√∫mero " + searchNumber + " est√° en el vector.");
        } else {
            System.out.println("El n√∫mero " + searchNumber + " no est√° en el vector.");
        }

        // Obtener el √≠ndice de un elemento
        int index = numbers.indexOf(15);
        System.out.println("El √≠ndice de 15 es: " + index);
    }
}
---6---
import java.util.Collections;
import java.util.Vector;

public class SortVector {
    public static void main(String[] args) {
        // Crear un vector de n√∫meros
        Vector<Integer> numbers = new Vector<>();
        numbers.add(30);
        numbers.add(10);
        numbers.add(20);
        numbers.add(40);

        // Ordenar el vector en orden ascendente
        Collections.sort(numbers);
        System.out.println("Vector ordenado (ascendente): " + numbers);

        // Ordenar el vector en orden descendente
        Collections.sort(numbers, Collections.reverseOrder());
        System.out.println("Vector ordenado (descendente): " + numbers);
    }
}
---7---
import java.util.Vector;

public class VectorCapacity {
    public static void main(String[] args) {
        // Crear un vector con una capacidad inicial de 2
        Vector<String> items = new Vector<>(2);

        // Agregar elementos al vector
        items.add("Manzana");
        items.add("Banana");

        // Mostrar la capacidad actual
        System.out.println("Capacidad actual: " + items.capacity());

        // Agregar m√°s elementos para exceder la capacidad inicial
        items.add("Cereza");
        System.out.println("Capacidad despu√©s de agregar m√°s elementos: " + items.capacity());

        // Mostrar los elementos del vector
        System.out.println("Elementos del vector: " + items);
    }
}
---8---
import java.util.Vector;

public class VectorToArray {
    public static void main(String[] args) {
        // Crear un vector de n√∫meros
        Vector<Integer> numbers = new Vector<>();
        numbers.add(10);
        numbers.add(20);
        numbers.add(30);

        // Convertir el vector a un array
        Integer[] array = numbers.toArray(new Integer[0]);

        // Imprimir los elementos del array
        System.out.println("Elementos del array:");
        for (int num : array) {
            System.out.println(num);
        }
    }
}
---EJERCICIOS - PARTE 1
---9---
import java.util.Vector;
import java.util.Random;

public class VectorExecutionTime {
    public static void main(String[] args) {
        // Generar un vector con n√∫meros aleatorios
        int size = 100000; // Tama√±o del vector
        Vector<Integer> numbers = new Vector<>();
        Random random = new Random();

        for (int i = 0; i < size; i++) {
            numbers.add(random.nextInt(1000)); // N√∫meros aleatorios entre 0 y 999
        }

        // Medir el tiempo de inicio
        long startTime = System.nanoTime();

        // Recorrer el vector
        int sum = 0;
        for (int num : numbers) {
            sum += num; // Calcular la suma de los elementos
        }

        // Medir el tiempo de fin
        long endTime = System.nanoTime();

        // Calcular el tiempo de ejecuci√≥n
        long duration = endTime - startTime; // Tiempo en nanosegundos

        // Mostrar resultados
        System.out.println("Suma de los elementos: " + sum);
        System.out.println("Tiempo de ejecuci√≥n: " + duration + " nanosegundos");
        System.out.println("Tiempo de ejecuci√≥n: " + (duration / 1_000_000) + " milisegundos");
    }
}
---10---
import java.util.ArrayList;
import java.util.Random;

public class ComplexityComparison {
    public static void main(String[] args) {
        // Tama√±os de entrada
        int[] inputSizes = {100, 1000, 10000, 100000};

        // Crear encabezado de tabla
        System.out.printf("%-10s %-15s %-15s %-15s%n", "Input Size", "O(n)", "O(n^2)", "O(log n)");

        for (int size : inputSizes) {
            // Medir complejidad O(n)
            long startTime = System.nanoTime();
            linearComplexity(size);
            long durationOn = System.nanoTime() - startTime;

            // Medir complejidad O(n^2)
            startTime = System.nanoTime();
            quadraticComplexity(size / 100); // Reducir tama√±o para evitar largos tiempos de ejecuci√≥n
            long durationOn2 = System.nanoTime() - startTime;

            // Medir complejidad O(log n)
            startTime = System.nanoTime();
            logarithmicComplexity(size);
            long durationOlogn = System.nanoTime() - startTime;

            // Mostrar resultados con 10 d√≠gitos
            System.out.printf("%-10d %-15s %-15s %-15s%n", 
                              size, 
                              String.format("%010d", durationOn / 1_000_000), 
                              String.format("%010d", durationOn2 / 1_000_000), 
                              String.format("%010d", durationOlogn / 1_000_000));
        }
    }

    // O(n): Recorrido lineal de un arreglo
    public static void linearComplexity(int size) {
        ArrayList<Integer> numbers = new ArrayList<>();
        Random random = new Random();
        for (int i = 0; i < size; i++) {
            numbers.add(random.nextInt(1000));
        }
        int sum = 0;
        for (int num : numbers) {
            sum += num;
        }
    }

    // O(n^2): Comparaci√≥n de todos los pares en un arreglo
    public static void quadraticComplexity(int size) {
        ArrayList<Integer> numbers = new ArrayList<>();
        Random random = new Random();
        for (int i = 0; i < size; i++) {
            numbers.add(random.nextInt(1000));
        }
        for (int i = 0; i < size; i++) {
            for (int j = 0; j < size; j++) {
                int product = numbers.get(i) * numbers.get(j); // Simula trabajo
            }
        }
    }

    // O(log n): B√∫squeda binaria en un arreglo ordenado
    public static void logarithmicComplexity(int size) {
        ArrayList<Integer> numbers = new ArrayList<>();
        for (int i = 0; i < size; i++) {
            numbers.add(i); // Generar un arreglo ordenado
        }
        int target = new Random().nextInt(size);

        // B√∫squeda binaria
        int left = 0, right = size - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (numbers.get(mid) == target) {
                return; // Elemento encontrado
            } else if (numbers.get(mid) < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
    }
}

---11---
public class ExecutionTimeComparison {
    public static void main(String[] args) {
        int n = 1000000; // Tama√±o del problema

        System.out.println("Comparaci√≥n de tiempos para calcular la suma del 1 al " + n);
        System.out.printf("%-30s %-15s%n", "M√©todo", "Tiempo (ms)");

        // Enfoque 1: Usando un bucle for
        long startTime = System.nanoTime();
        long sumFor = sumUsingForLoop(n);
        long endTime = System.nanoTime();
        System.out.printf("%-30s %-15d%n", "Bucle for", (endTime - startTime) / 1_000_000);

        // Enfoque 2: Usando un bucle while
        startTime = System.nanoTime();
        long sumWhile = sumUsingWhileLoop(n);
        endTime = System.nanoTime();
        System.out.printf("%-30s %-15d%n", "Bucle while", (endTime - startTime) / 1_000_000);

        // Enfoque 3: Usando un bucle do-while
        startTime = System.nanoTime();
        long sumDoWhile = sumUsingDoWhileLoop(n);
        endTime = System.nanoTime();
        System.out.printf("%-30s %-15d%n", "Bucle do-while", (endTime - startTime) / 1_000_000);

        // Enfoque 4: Usando la f√≥rmula matem√°tica
        startTime = System.nanoTime();
        long sumFormula = sumUsingFormula(n);
        endTime = System.nanoTime();
        System.out.printf("%-30s %-15d%n", "F√≥rmula matem√°tica", (endTime - startTime) / 1_000_000);

        // Validar resultados
        if (sumFor == sumWhile && sumWhile == sumDoWhile && sumDoWhile == sumFormula) {
            System.out.println("Todos los m√©todos producen el mismo resultado: " + sumFormula);
        } else {
            System.out.println("¬°Los resultados no coinciden entre los m√©todos!");
        }
    }

    // M√©todo 1: Usando un bucle for
    public static long sumUsingForLoop(int n) {
        long sum = 0;
        for (int i = 1; i <= n; i++) {
            sum += i;
        }
        return sum;
    }

    // M√©todo 2: Usando un bucle while
    public static long sumUsingWhileLoop(int n) {
        long sum = 0;
        int i = 1;
        while (i <= n) {
            sum += i;
            i++;
        }
        return sum;
    }

    // M√©todo 3: Usando un bucle do-while
    public static long sumUsingDoWhileLoop(int n) {
        long sum = 0;
        int i = 1;
        do {
            sum += i;
            i++;
        } while (i <= n);
        return sum;
    }

    // M√©todo 4: Usando la f√≥rmula matem√°tica
    public static long sumUsingFormula(int n) {
        return (long) n * (n + 1) / 2; // F√≥rmula: n(n + 1) / 2
    }
}
---12---
import java.util.Random;

public class MaxNumberComparison {
    public static void main(String[] args) {
        int n = 1000000; // Tama√±o del arreglo
        int[] numbers = generateRandomArray(n); // Generar un arreglo aleatorio

        System.out.println("Comparaci√≥n de tiempos para encontrar el mayor n√∫mero en un arreglo de tama√±o " + n);
        System.out.printf("%-30s %-15s%n", "M√©todo", "Tiempo (ms)");

        // Enfoque 1: Usando un bucle for
        long startTime = System.nanoTime();
        int maxFor = findMaxUsingForLoop(numbers);
        long endTime = System.nanoTime();
        System.out.printf("%-30s %-15d%n", "Bucle for", (endTime - startTime) / 1_000_000);

        // Enfoque 2: Usando un bucle while
        startTime = System.nanoTime();
        int maxWhile = findMaxUsingWhileLoop(numbers);
        endTime = System.nanoTime();
        System.out.printf("%-30s %-15d%n", "Bucle while", (endTime - startTime) / 1_000_000);

        // Enfoque 3: Usando un bucle do-while
        startTime = System.nanoTime();
        int maxDoWhile = findMaxUsingDoWhileLoop(numbers);
        endTime = System.nanoTime();
        System.out.printf("%-30s %-15d%n", "Bucle do-while", (endTime - startTime) / 1_000_000);

        // Enfoque 4: Usando Arrays.stream() (API de Streams)
        startTime = System.nanoTime();
        int maxStream = findMaxUsingStream(numbers);
        endTime = System.nanoTime();
        System.out.printf("%-30s %-15d%n", "Streams API", (endTime - startTime) / 1_000_000);

        // Validar resultados
        if (maxFor == maxWhile && maxWhile == maxDoWhile && maxDoWhile == maxStream) {
            System.out.println("Todos los m√©todos producen el mismo resultado: " + maxStream);
        } else {
            System.out.println("¬°Los resultados no coinciden entre los m√©todos!");
        }
    }

    // M√©todo auxiliar: Generar un arreglo aleatorio
    public static int[] generateRandomArray(int size) {
        Random random = new Random();
        int[] array = new int[size];
        for (int i = 0; i < size; i++) {
            array[i] = random.nextInt(1000000); // N√∫meros entre 0 y 999,999
        }
        return array;
    }

    // Enfoque 1: Usando un bucle for
    public static int findMaxUsingForLoop(int[] array) {
        int max = Integer.MIN_VALUE;
        for (int num : array) {
            if (num > max) {
                max = num;
            }
        }
        return max;
    }

    // Enfoque 2: Usando un bucle while
    public static int findMaxUsingWhileLoop(int[] array) {
        int max = Integer.MIN_VALUE;
        int i = 0;
        while (i < array.length) {
            if (array[i] > max) {
                max = array[i];
            }
            i++;
        }
        return max;
    }

    // Enfoque 3: Usando un bucle do-while
    public static int findMaxUsingDoWhileLoop(int[] array) {
        int max = Integer.MIN_VALUE;
        int i = 0;
        do {
            if (array[i] > max) {
                max = array[i];
            }
            i++;
        } while (i < array.length);
        return max;
    }

    // Enfoque 4: Usando Streams API
    public static int findMaxUsingStream(int[] array) {
        return java.util.Arrays.stream(array).max().orElse(Integer.MIN_VALUE);
    }
}
---13---
import java.util.HashMap;
import java.util.Map;
import java.util.Random;

public class FrequencyCountComparison {
    public static void main(String[] args) {
        int n = 100000; // Tama√±o del arreglo
        int[] numbers = generateRandomArray(n); // Generar un arreglo aleatorio

        System.out.println("Comparaci√≥n de tiempos para contar la frecuencia de n√∫meros en un arreglo de tama√±o " + n);
        System.out.printf("%-30s %-15s%n", "M√©todo", "Tiempo (ms)");

        // Enfoque 1: Usando un HashMap con un bucle for
        long startTime = System.nanoTime();
        Map<Integer, Integer> frequencyMapFor = countFrequencyUsingForLoop(numbers);
        long endTime = System.nanoTime();
        System.out.printf("%-30s %-15d%n", "HashMap con for", (endTime - startTime) / 1_000_000);

        // Enfoque 2: Usando un HashMap con un bucle for-each
        startTime = System.nanoTime();
        Map<Integer, Integer> frequencyMapForEach = countFrequencyUsingForEach(numbers);
        endTime = System.nanoTime();
        System.out.printf("%-30s %-15d%n", "HashMap con for-each", (endTime - startTime) / 1_000_000);

        // Enfoque 3: Usando Streams API
        startTime = System.nanoTime();
        Map<Integer, Long> frequencyMapStream = countFrequencyUsingStream(numbers);
        endTime = System.nanoTime();
        System.out.printf("%-30s %-15d%n", "Streams API", (endTime - startTime) / 1_000_000);

        // Validar resultados
        System.out.println("Resultados:");
        System.out.println("Ejemplo de frecuencia con for: " + frequencyMapFor.entrySet().stream().limit(5).toList());
        System.out.println("Ejemplo de frecuencia con for-each: " + frequencyMapForEach.entrySet().stream().limit(5).toList());
        System.out.println("Ejemplo de frecuencia con Streams: " + frequencyMapStream.entrySet().stream().limit(5).toList());
    }

    // M√©todo auxiliar: Generar un arreglo aleatorio
    public static int[] generateRandomArray(int size) {
        Random random = new Random();
        int[] array = new int[size];
        for (int i = 0; i < size; i++) {
            array[i] = random.nextInt(100); // N√∫meros entre 0 y 99
        }
        return array;
    }

    // Enfoque 1: Usando un HashMap con un bucle for
    public static Map<Integer, Integer> countFrequencyUsingForLoop(int[] array) {
        Map<Integer, Integer> frequencyMap = new HashMap<>();
        for (int i = 0; i < array.length; i++) {
            frequencyMap.put(array[i], frequencyMap.getOrDefault(array[i], 0) + 1);
        }
        return frequencyMap;
    }

    // Enfoque 2: Usando un HashMap con un bucle for-each
    public static Map<Integer, Integer> countFrequencyUsingForEach(int[] array) {
        Map<Integer, Integer> frequencyMap = new HashMap<>();
        for (int num : array) {
            frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);
        }
        return frequencyMap;
    }

    // Enfoque 3: Usando Streams API
    public static Map<Integer, Long> countFrequencyUsingStream(int[] array) {
        return java.util.Arrays.stream(array)
                .boxed()
                .collect(java.util.stream.Collectors.groupingBy(num -> num, java.util.stream.Collectors.counting()));
    }
}
---EJERCICIOS PARTE2
---14---
import java.util.Scanner;

public class InnovativeMenu {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int option;

        do {
            // Mostrar el men√∫
            printMenu();

            // Leer la opci√≥n del usuario
            System.out.print("\nSeleccione una opci√≥n (1-4): ");
            option = scanner.nextInt();

            // Ejecutar la opci√≥n seleccionada
            switch (option) {
                case 1:
                    System.out.println("\n--- Opci√≥n 1: Encontrar N√∫meros √önicos ---");
                    solveUniqueNumbers();
                    break;
                case 2:
                    System.out.println("\n--- Opci√≥n 2: Calcular Intersecci√≥n de Arreglos ---");
                    solveArrayIntersection();
                    break;
                case 3:
                    System.out.println("\n--- Opci√≥n 3: Mostrar Informaci√≥n Sobre el Programa ---");
                    showProgramInfo();
                    break;
                case 4:
                    System.out.println("\nGracias por usar el programa. ¬°Hasta luego!");
                    break;
                default:
                    System.out.println("\nOpci√≥n no v√°lida. Int√©ntelo nuevamente.");
            }
        } while (option != 4);

        scanner.close();
    }

    // M√©todo para imprimir el men√∫ de forma innovadora
    public static void printMenu() {
        System.out.println("\n==============================");
        System.out.println("|     MEN√ö DE EJERCICIOS     |");
        System.out.println("==============================");
        System.out.println("|  1. Encontrar N√∫meros √önicos |");
        System.out.println("|  2. Calcular Intersecci√≥n     |");
        System.out.println("|  3. Informaci√≥n del Programa  |");
        System.out.println("|  4. Salir                    |");
        System.out.println("==============================");
    }

    // Resolver ejercicio: Encontrar n√∫meros √∫nicos
    public static void solveUniqueNumbers() {
        int[] array = {4, 5, 6, 4, 7, 8, 8, 9, 10, 5};
        int[] uniqueNumbers = findUniqueNumbers(array);
        System.out.println("N√∫meros √∫nicos: ");
        printArray(uniqueNumbers);
    }

    // Resolver ejercicio: Calcular intersecci√≥n de arreglos
    public static void solveArrayIntersection() {
        int[] array1 = {1, 2, 3, 4, 5, 6, 7, 8};
        int[] array2 = {5, 6, 7, 8, 9, 10};
        int[] intersection = findArrayIntersection(array1, array2);
        System.out.println("Intersecci√≥n de arreglos: ");
        printArray(intersection);
    }

    // Mostrar informaci√≥n sobre el programa
    public static void showProgramInfo() {
        System.out.println("\n--- Informaci√≥n del Programa ---");
        System.out.println("Este programa permite resolver diferentes ejercicios interactivos:");
        System.out.println("1. Encontrar n√∫meros √∫nicos en un arreglo.");
        System.out.println("2. Calcular la intersecci√≥n de dos arreglos.");
        System.out.println("Dise√±ado para practicar estructuras de datos y operaciones b√°sicas.");
    }

    // M√©todo para encontrar n√∫meros √∫nicos (reutilizado)
    public static int[] findUniqueNumbers(int[] array) {
        int uniqueCount = 0;

        // Contar n√∫meros √∫nicos
        for (int i = 0; i < array.length; i++) {
            boolean isUnique = true;
            for (int j = 0; j < array.length; j++) {
                if (i != j && array[i] == array[j]) {
                    isUnique = false;
                    break;
                }
            }
            if (isUnique) {
                uniqueCount++;
            }
        }

        // Crear arreglo de n√∫meros √∫nicos
        int[] uniqueNumbers = new int[uniqueCount];
        int index = 0;
        for (int i = 0; i < array.length; i++) {
            boolean isUnique = true;
            for (int j = 0; j < array.length; j++) {
                if (i != j && array[i] == array[j]) {
                    isUnique = false;
                    break;
                }
            }
            if (isUnique) {
                uniqueNumbers[index++] = array[i];
            }
        }
        return uniqueNumbers;
    }

    // M√©todo para calcular la intersecci√≥n de arreglos (reutilizado)
    public static int[] findArrayIntersection(int[] array1, int[] array2) {
        int count = 0;

        // Contar elementos comunes
        for (int num1 : array1) {
            for (int num2 : array2) {
                if (num1 == num2) {
                    count++;
                    break;
                }
            }
        }

        // Crear arreglo de intersecci√≥n
        int[] intersection = new int[count];
        int index = 0;
        for (int num1 : array1) {
            for (int num2 : array2) {
                if (num1 == num2) {
                    intersection[index++] = num1;
                    break;
                }
            }
        }
        return intersection;
    }

    // M√©todo auxiliar para imprimir arreglos
    public static void printArray(int[] array) {
        System.out.print("[");
        for (int i = 0; i < array.length; i++) {
            System.out.print(array[i]);
            if (i < array.length - 1) {
                System.out.print(", ");
            }
        }
        System.out.println("]");
    }
}
---15---
import java.util.Scanner;

public class NarrativeMenu {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int option;

        System.out.println("¬°Bienvenido al programa interactivo de ejercicios!");
        System.out.println("¬øEst√°s listo para explorar las opciones disponibles?");

        do {
            // Mostrar el men√∫
            showMenu();

            // Leer la opci√≥n del usuario
            System.out.print("\n¬øQu√© te gustar√≠a hacer? (Ingresa un n√∫mero del 1 al 4): ");
            option = scanner.nextInt();

            // Ejecutar la opci√≥n seleccionada
            switch (option) {
                case 1:
                    System.out.println("\nüåü Has elegido: Encontrar n√∫meros √∫nicos üåü");
                    solveUniqueNumbers();
                    break;
                case 2:
                    System.out.println("\nüîó Has elegido: Calcular la intersecci√≥n de arreglos üîó");
                    solveArrayIntersection();
                    break;
                case 3:
                    System.out.println("\nüìö Has elegido: Conocer m√°s sobre este programa üìö");
                    showProgramDetails();
                    break;
                case 4:
                    System.out.println("\n‚ú® Gracias por explorar conmigo. ¬°Hasta pronto! ‚ú®");
                    break;
                default:
                    System.out.println("\n‚ö†Ô∏è Opci√≥n no v√°lida. Por favor, intenta nuevamente.");
            }
        } while (option != 4);

        scanner.close();
    }

    // M√©todo para mostrar el men√∫
    public static void showMenu() {
        System.out.println("\n======================");
        System.out.println("üåü MEN√ö INTERACTIVO üåü");
        System.out.println("======================");
        System.out.println("1. Encontrar n√∫meros √∫nicos en un arreglo.");
        System.out.println("2. Calcular la intersecci√≥n entre dos arreglos.");
        System.out.println("3. Saber m√°s sobre el programa.");
        System.out.println("4. Salir del programa.");
    }

    // Resolver ejercicio: Encontrar n√∫meros √∫nicos
    public static void solveUniqueNumbers() {
        int[] array = {4, 5, 6, 4, 7, 8, 8, 9, 10, 5};
        System.out.println("Trabajaremos con el siguiente arreglo: ");
        printArray(array);
        int[] uniqueNumbers = findUniqueNumbers(array);
        System.out.println("N√∫meros √∫nicos encontrados:");
        printArray(uniqueNumbers);
    }

    // Resolver ejercicio: Calcular intersecci√≥n de arreglos
    public static void solveArrayIntersection() {
        int[] array1 = {1, 2, 3, 4, 5, 6, 7, 8};
        int[] array2 = {5, 6, 7, 8, 9, 10};
        System.out.println("Trabajaremos con los siguientes arreglos:");
        System.out.print("Arreglo 1: ");
        printArray(array1);
        System.out.print("Arreglo 2: ");
        printArray(array2);
        int[] intersection = findArrayIntersection(array1, array2);
        System.out.println("Intersecci√≥n encontrada:");
        printArray(intersection);
    }

    // Mostrar detalles del programa
    public static void showProgramDetails() {
        System.out.println("\nüåü Este programa est√° dise√±ado para:");
        System.out.println("1. Practicar operaciones con arreglos.");
        System.out.println("2. Explorar diferentes algoritmos para resolver problemas comunes.");
        System.out.println("3. Comparar enfoques y analizar resultados.");
        System.out.println("\n¬°Espero que disfrutes us√°ndolo! üöÄ");
    }

    // M√©todo para encontrar n√∫meros √∫nicos
    public static int[] findUniqueNumbers(int[] array) {
        int uniqueCount = 0;

        // Contar n√∫meros √∫nicos
        for (int i = 0; i < array.length; i++) {
            boolean isUnique = true;
            for (int j = 0; j < array.length; j++) {
                if (i != j && array[i] == array[j]) {
                    isUnique = false;
                    break;
                }
            }
            if (isUnique) {
                uniqueCount++;
            }
        }

        // Crear arreglo de n√∫meros √∫nicos
        int[] uniqueNumbers = new int[uniqueCount];
        int index = 0;
        for (int i = 0; i < array.length; i++) {
            boolean isUnique = true;
            for (int j = 0; j < array.length; j++) {
                if (i != j && array[i] == array[j]) {
                    isUnique = false;
                    break;
                }
            }
            if (isUnique) {
                uniqueNumbers[index++] = array[i];
            }
        }
        return uniqueNumbers;
    }

    // M√©todo para calcular la intersecci√≥n de arreglos
    public static int[] findArrayIntersection(int[] array1, int[] array2) {
        int count = 0;

        // Contar elementos comunes
        for (int num1 : array1) {
            for (int num2 : array2) {
                if (num1 == num2) {
                    count++;
                    break;
                }
            }
        }

        // Crear arreglo de intersecci√≥n
        int[] intersection = new int[count];
        int index = 0;
        for (int num1 : array1) {
            for (int num2 : array2) {
                if (num1 == num2) {
                    intersection[index++] = num1;
                    break;
                }
            }
        }
        return intersection;
    }

    // M√©todo auxiliar para imprimir arreglos
    public static void printArray(int[] array) {
        System.out.print("[");
        for (int i = 0; i < array.length; i++) {
            System.out.print(array[i]);
            if (i < array.length - 1) {
                System.out.print(", ");
            }
        }
        System.out.println("]");
    }
}
---16---
import java.util.Scanner;

public class ThematicMenu {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int option;

        do {
            // Mostrar el men√∫ principal
            printMenu();

            // Leer la opci√≥n del usuario
            System.out.print("\nElige una opci√≥n (1-5): ");
            option = scanner.nextInt();

            // Ejecutar la opci√≥n seleccionada
            switch (option) {
                case 1:
                    System.out.println("\n>>> RESOLVER: Encontrar n√∫meros √∫nicos <<<");
                    solveUniqueNumbers();
                    break;
                case 2:
                    System.out.println("\n>>> RESOLVER: Calcular intersecci√≥n de arreglos <<<");
                    solveArrayIntersection();
                    break;
                case 3:
                    System.out.println("\n>>> EXPLORAR: Ejercicios avanzados <<<");
                    showAdvancedExercises();
                    break;
                case 4:
                    System.out.println("\n>>> INFORMACI√ìN: Sobre este programa <<<");
                    showProgramDetails();
                    break;
                case 5:
                    System.out.println("\n>>> SALIR: Gracias por usar este programa. ¬°Adi√≥s! <<<");
                    break;
                default:
                    System.out.println("\n[!] Opci√≥n inv√°lida. Por favor, elige nuevamente.");
            }
        } while (option != 5);

        scanner.close();
    }

    // M√©todo para imprimir el men√∫ principal
    public static void printMenu() {
        System.out.println("\n============================");
        System.out.println("   MEN√ö TEM√ÅTICO PRINCIPAL   ");
        System.out.println("============================");
        System.out.println("1. Resolver: Encontrar n√∫meros √∫nicos");
        System.out.println("2. Resolver: Calcular intersecci√≥n de arreglos");
        System.out.println("3. Explorar: Ejercicios avanzados");
        System.out.println("4. Informaci√≥n: Sobre este programa");
        System.out.println("5. Salir del programa");
        System.out.println("============================");
    }

    // Resolver ejercicio: Encontrar n√∫meros √∫nicos
    public static void solveUniqueNumbers() {
        int[] array = {4, 5, 6, 4, 7, 8, 8, 9, 10, 5};
        System.out.println("Arreglo de trabajo: ");
        printArray(array);
        int[] uniqueNumbers = findUniqueNumbers(array);
        System.out.println("N√∫meros √∫nicos encontrados:");
        printArray(uniqueNumbers);
    }

    // Resolver ejercicio: Calcular intersecci√≥n de arreglos
    public static void solveArrayIntersection() {
        int[] array1 = {1, 2, 3, 4, 5, 6, 7, 8};
        int[] array2 = {5, 6, 7, 8, 9, 10};
        System.out.println("Arreglos de trabajo:");
        System.out.print("Arreglo 1: ");
        printArray(array1);
        System.out.print("Arreglo 2: ");
        printArray(array2);
        int[] intersection = findArrayIntersection(array1, array2);
        System.out.println("Intersecci√≥n encontrada:");
        printArray(intersection);
    }

    // Explorar ejercicios avanzados
    public static void showAdvancedExercises() {
        System.out.println("\n>>> Ejercicios avanzados disponibles <<<");
        System.out.println("1. Encontrar el n√∫mero m√°s repetido en un arreglo.");
        System.out.println("2. Calcular la uni√≥n de dos arreglos.");
        System.out.println("3. Ordenar un arreglo en orden descendente.");
        System.out.println("Explora estos desaf√≠os en futuras versiones del programa.");
    }

    // Mostrar informaci√≥n sobre el programa
    public static void showProgramDetails() {
        System.out.println("\n>>> Sobre este programa <<<");
        System.out.println("Este programa est√° dise√±ado para resolver problemas comunes con arreglos:");
        System.out.println("- Encontrar n√∫meros √∫nicos.");
        System.out.println("- Calcular intersecciones entre arreglos.");
        System.out.println("- Practicar l√≥gica de programaci√≥n y estructuras b√°sicas.");
        System.out.println("Esperamos que lo encuentres √∫til para tus estudios y pr√°cticas.");
    }

    // M√©todo para encontrar n√∫meros √∫nicos
    public static int[] findUniqueNumbers(int[] array) {
        int uniqueCount = 0;

        // Contar n√∫meros √∫nicos
        for (int i = 0; i < array.length; i++) {
            boolean isUnique = true;
            for (int j = 0; j < array.length; j++) {
                if (i != j && array[i] == array[j]) {
                    isUnique = false;
                    break;
                }
            }
            if (isUnique) {
                uniqueCount++;
            }
        }

        // Crear arreglo de n√∫meros √∫nicos
        int[] uniqueNumbers = new int[uniqueCount];
        int index = 0;
        for (int i = 0; i < array.length; i++) {
            boolean isUnique = true;
            for (int j = 0; j < array.length; j++) {
                if (i != j && array[i] == array[j]) {
                    isUnique = false;
                    break;
                }
            }
            if (isUnique) {
                uniqueNumbers[index++] = array[i];
            }
        }
        return uniqueNumbers;
    }

    // M√©todo para calcular la intersecci√≥n de arreglos
    public static int[] findArrayIntersection(int[] array1, int[] array2) {
        int count = 0;

        // Contar elementos comunes
        for (int num1 : array1) {
            for (int num2 : array2) {
                if (num1 == num2) {
                    count++;
                    break;
                }
            }
        }

        // Crear arreglo de intersecci√≥n
        int[] intersection = new int[count];
        int index = 0;
        for (int num1 : array1) {
            for (int num2 : array2) {
                if (num1 == num2) {
                    intersection[index++] = num1;
                    break;
                }
            }
        }
        return intersection;
    }

    // M√©todo auxiliar para imprimir arreglos
    public static void printArray(int[] array) {
        System.out.print("[");
        for (int i = 0; i < array.length; i++) {
            System.out.print(array[i]);
            if (i < array.length - 1) {
                System.out.print(", ");
            }
        }
        System.out.println("]");
    }
}
